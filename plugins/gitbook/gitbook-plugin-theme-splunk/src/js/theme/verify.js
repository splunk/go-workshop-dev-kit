/* global fetch */

import _ from 'underscore'
import React from 'react'
import ReactDOM from 'react-dom'
import * as $ from 'jquery'

import { reportError } from './error_report'
import { RatingModal } from './components/rating_modal.jsx'
import { Verify } from './components/verify.jsx'
import { ScriptBlock } from './components/verify_script.jsx'
import { QuizBlock } from './components/verify_quiz.jsx'
import { SurveyBlock } from './components/verify_survey.jsx'
import { ConfirmBlock } from './components/verify_confirm.jsx'
import { CodelabBlock } from './components/verify_codelab.jsx'

const gitbook = window.gitbook
const urlVerify = 'api/verify'
const urlRating = 'api/rating'

class VerifyBlock {
  constructor (topElem, userState, featureState, hideBlocks) {
    this.$topElem = $(topElem)
    this.userState = userState
    this.featureState = featureState

    // Check if users arrived to this workshop from a track
    this.fromTrack = !_.isEmpty(gitbook.storage.get('track'))
    this.urlHub = featureState.urlHub + gitbook.storage.get('track')

    // Get target name from button element.
    // HTML block for the button is injected when static assets are
    // generated by SDK.
    this.target = this.$topElem.attr('target')
    this.readyMessage = this.$topElem.attr('readyMessage')
    this.doneMessage = this.$topElem.attr('doneMessage')

    // Get the target definition for this verify button.

    // NOTE: Be very careful when using targetDef because there are some
    // default values that may not exist in Book.json but populated later
    // by the verifier parser.
    //
    // In the future, we probably want to get targetDef from backend instead
    // of using un-sanitized value within book.json directly

    const verifyDefs = gitbook.state.config.features.verify

    if (_.isBoolean(verifyDefs) && verifyDefs) {
      // This is for backward compatibility.
      // TODO : Address this in one place. currently this is handled
      // in multiple places
      if (this.target.includes('.js')) {
        this.targetDef = { name: 'verify', type: 'script', input: [] }
      } else {
        this.targetDef = { name: 'confirm', type: 'confirm', input: [] }
      }
    } else if (_.isObject(verifyDefs) && _.isArray(verifyDefs.targets)) {
      const verifyDefsByName = _.indexBy(verifyDefs.targets, 'name')
      if (verifyDefsByName[this.target]) {
        this.targetDef = verifyDefsByName[this.target]
      }
      // override urlHub wth custom redirectUrl
      if (verifyDefs.redirectUrl) {
        this.urlHub = verifyDefs.redirectUrl
      }
    }
    if (this.targetDef) {
      if (
        this.targetDef.type === 'script' &&
        !_.isArray(this.targetDef.input)
      ) {
        this.targetDef.input = []
      }
    }

    const isWorkshopCompleted = userState.progress === 'completed'
    const isTargetCompleted =
      _.isObject(userState.targetsCompleted) &&
      userState.targetsCompleted[this.target]
    this.completed = isWorkshopCompleted || isTargetCompleted

    // Check if a conditional block that matches this target is defined.
    // If defined, it will be revealed when this target is completed
    this.hideBlock = hideBlocks[this.target]
  }

  async init () {
    // Skip rendering the button if provided target is not defined in
    // book.json
    if (!this.targetDef) {
      console.log(`Invalid target "${this.target}"`)
      return
    }

    try {
      const handleAccepted = ({ final }) => {
        this.updateScroll()
        if (this.hideBlock) {
          this.hideBlock.show()
        }
        if (final) {
          this.handleFinal()
        }
      }
      const handleFailed = () => {
        this.updateScroll()
      }

      if (this.targetDef.type === 'script') {
        ReactDOM.render(
          <ScriptBlock
            targetDef={this.targetDef}
            readyMessage={this.readyMessage}
            doneMessage={this.doneMessage}
            status={this.completed ? 'done' : 'ready'}
            onVerifyRequest={this.sendVerifyRequest.bind(this)}
            onFailed={handleFailed}
            onAccepted={handleAccepted}
          />,
          this.$topElem.find('.verify').get(0)
        )
      } else if (this.targetDef.type === 'quiz') {
        ReactDOM.render(
          <QuizBlock
            targetDef={this.targetDef}
            readyMessage={this.readyMessage}
            doneMessage={this.doneMessage}
            status={this.completed ? 'done' : 'ready'}
            onVerifyRequest={this.sendVerifyRequest.bind(this)}
            onAccepted={handleAccepted}
          />,
          this.$topElem.find('.verify').get(0)
        )
      } else if (this.targetDef.type === 'survey') {
        ReactDOM.render(
          <SurveyBlock
            targetDef={this.targetDef}
            readyMessage={this.readyMessage}
            doneMessage={this.doneMessage}
            status={this.completed ? 'done' : 'ready'}
            onVerifyRequest={this.sendVerifyRequest.bind(this)}
            onAccepted={handleAccepted}
          />,
          this.$topElem.find('.verify').get(0)
        )
      } else if (this.targetDef.type === 'codelab') {
        ReactDOM.render(
          <CodelabBlock
            targetDef={this.targetDef}
            readyMessage={this.readyMessage}
            doneMessage={this.doneMessage}
            status={this.completed ? 'done' : 'ready'}
            onVerifyRequest={this.sendVerifyRequest.bind(this)}
            onFailed={handleFailed}
            onAccepted={handleAccepted}
          />,
          this.$topElem.find('.verify').get(0)
        )
      } else if (this.targetDef.type === 'confirm') {
        ReactDOM.render(
          <ConfirmBlock
            targetDef={this.targetDef}
            readyMessage={this.readyMessage}
            doneMessage={this.doneMessage}
            status={this.completed ? 'done' : 'ready'}
            onVerifyRequest={this.sendVerifyRequest.bind(this)}
            onAccepted={handleAccepted}
          />,
          this.$topElem.find('.verify').get(0)
        )
      }
    } catch (err) {
      const message =
        'Failed to initialize verify block for ' +
        `${this.target}, message: ${err.message}`
      await reportError({ message: message, stack: err.stack })
    }
  }

  updateScroll () {
    const $messageBox = this.$topElem.find('.message-box')
    const targetOffsetTop = $messageBox.offset().top
    const targetHeight = $messageBox.height()
    const currentPosition = $('.body-inner').scrollTop()
    const currentHeight = $('.body-inner').height()
    const bottomMargin = 48
    const newPosition =
      currentPosition +
      targetOffsetTop -
      currentHeight +
      targetHeight +
      bottomMargin
    $('.body-inner').scrollTop(newPosition)
  }

  handleFinal () {
    console.log('handleFinal')
    const showRatingView =
      !_.isNumber(this.userState.rating) && this.featureState.nps
    if (showRatingView) {
      const handleComplete = () => {
        console.log('handleComplete')
        this.showCompletionDialog()
      }
      ReactDOM.render(
        <RatingModal
          show
          url={gitbook.getAbsoluteUrl(urlRating)}
          onComplete={handleComplete}
        />,
        this.$topElem.find('.rate').get(0)
      )
    } else {
      this.showCompletionDialog()
    }
  }

  showCompletionDialog () {
    ReactDOM.render(
      <Verify.CompletionDialog
        show
        fromTrack={this.fromTrack}
        url={this.urlHub}
      />,
      this.$topElem.find('.complete').get(0)
    )
  }

  async sendVerifyRequest (target, data = {}) {
    const postObj = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json; charset=utf-8'
      },
      body: JSON.stringify({ target: target, data: data })
    }
    const response = await fetch(gitbook.getAbsoluteUrl(urlVerify), postObj)
    return response.json()
  }
}

class HideBlock {
  constructor (target, userState) {
    this.target = target
    this.userState = userState
    const isTargetCompleted =
      _.isObject(userState.targetsCompleted) &&
      userState.targetsCompleted[this.target]
    this.$elem = $(`.hide-verify[target=${this.target}]`)
    if (isTargetCompleted) {
      this.$elem.addClass('show')
    } else {
      this.$elem.removeClass('show')
    }
  }

  show () {
    this.$elem.addClass('show')
  }
}

async function fetchProgress () {
  const response = await fetch(gitbook.getAbsoluteUrl(urlVerify))
  const body = await response.json()
  if (body.error) {
    const msg = 'Received an error while fetching progress from server'
    const error = new Error(msg)
    throw error
  }
  return body.data
}

async function init (featureState) {
  try {
    const userState = await fetchProgress()
    const hideBlocks = {}
    $('.hide-verify').each((index, item) => {
      const target = $(item).attr('target')
      hideBlocks[target] = new HideBlock(target, userState)
    })
    $('.block-verify').each(async (index, elem) => {
      const verify = new VerifyBlock(elem, userState, featureState, hideBlocks)
      await verify.init()
    })
  } catch (err) {
    const msg =
      'Unexpected error during initialization of verify block' +
      `, message: ${err.message}`
    await reportError({ message: msg, stack: err.stack })
  }
}

export { init }
